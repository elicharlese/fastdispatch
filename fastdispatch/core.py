# AUTOGENERATED! DO NOT EDIT! File to edit: ../00_core.ipynb.

# %% ../00_core.ipynb 3
from __future__ import annotations
import inspect
from fastcore.meta import *
from fastcore.utils import *
from plum import Function, Dispatcher

# %% auto 0
__all__ = ['dispatch', 'FastFunction', 'FastDispatcher', 'retain_meta', 'default_set_meta', 'cast', 'retain_type', 'retain_types',
           'explode_types']

# %% ../00_core.ipynb 7
def _eval_annotations(f):
    "Evaluate future annotations before passing to plum to support backported union operator `|`"
    f = copy_func(f)
    for k, v in type_hints(f).items(): f.__annotations__[k] = Union[v] if isinstance(v, tuple) else v
    return f

# %% ../00_core.ipynb 9
def _pt_repr(o):
    "Concise repr of plum types"
    n = type(o).__name__
    if n == 'Tuple': return f"{n.lower()}[{','.join(_pt_repr(t) for t in o._el_types)}]"
    if n == 'List': return f'{n.lower()}[{_pt_repr(o._el_type)}]'
    if n == 'Dict': return f'{n.lower()}[{_pt_repr(o._key_type)},{_pt_repr(o._value_type)}]'
    if n in ('Sequence','Iterable'): return f'{n}[{_pt_repr(o._el_type)}]'
    if n == 'VarArgs': return f'{n}[{_pt_repr(o.type)}]'
    if n == 'Union': return '|'.join(sorted(t.__name__ for t in (o.get_types())))
    assert len(o.get_types()) == 1
    return o.get_types()[0].__name__

# %% ../00_core.ipynb 12
class FastFunction(Function):
    def __repr__(self):
        return '\n'.join(f"{f.__name__}({','.join(_pt_repr(t) for t in s.types)}) -> {_pt_repr(r)}"
                         for s, (f, r) in self.methods.items())

    def dispatch(self, f=None, precedence=0):
        return super().dispatch(_eval_annotations(f), precedence)

    def register(self, signature, f, precedence=0, return_type=object, delayed=None):
        self.__signature__ = inspect.signature(f)
        return super().register(signature, f, precedence, return_type, delayed)

    def __getitem__(self, ts):
        "Return the most-specific matching method with fewest parameters"
        ts = L(ts)
        nargs = min(len(o) for o in self.methods.keys())
        while len(ts) < nargs: ts.append(object)
        return self.invoke(*ts)

# %% ../00_core.ipynb 21
class FastDispatcher(Dispatcher):
    def _get_function(self, method, owner):
        "Adapted from `Dispatcher._get_function` to use `FastFunction`"
        name = method.__name__
        if owner:
            if owner not in self._classes: self._classes[owner] = {}
            namespace = self._classes[owner]
        else: namespace = self._functions
        if name not in namespace: namespace[name] = FastFunction(method, owner=owner)
        return namespace[name]

    @delegates(Dispatcher.__call__, but='method')
    def __call__(self, f, **kwargs): return super().__call__(_eval_annotations(f), **kwargs)

dispatch = FastDispatcher()

# %% ../00_core.ipynb 29
@patch
def _to(self:FastDispatcher, cls, nm, f, **kwargs):
    nf = copy_func(f)
    nf.__qualname__ = f'{cls.__name__}.{nm}' # plum uses __qualname__ to infer f's owner
    pf = self(nf, **kwargs)
    # plum uses __set_name__ to resolve a plum.Function's owner
    # since we assign after class creation, __set_name__ must be called directly
    # source: https://docs.python.org/3/reference/datamodel.html#object.__set_name__
    pf.__set_name__(cls, nm)
    pf = pf.resolve()
    setattr(cls, nm, pf)
    return pf

@patch
def to(self:FastDispatcher, cls):
    "Decorator: dispatch `f` to `cls.f`"
    def _inner(f, **kwargs):
        nm = f.__name__
        # check __dict__ to avoid inherited methods but use getattr so pf.__get__ is called, which plum relies on
        if nm in cls.__dict__:
            pf = getattr(cls, nm)
            if not hasattr(pf, 'dispatch'): pf = self._to(cls, nm, pf, **kwargs)
            pf.dispatch(f)
        else: pf = self._to(cls, nm, f, **kwargs)
        return pf
    return _inner

# %% ../00_core.ipynb 38
_all_=['cast']

# %% ../00_core.ipynb 39
def retain_meta(x, res, as_copy=False):
    "Call `res.set_meta(x)`, if it exists"
    if hasattr(res,'set_meta'): res.set_meta(x, as_copy=as_copy)
    return res

# %% ../00_core.ipynb 40
def default_set_meta(self, x, as_copy=False):
    "Copy over `_meta` from `x` to `res`, if it's missing"
    if hasattr(x, '_meta') and not hasattr(self, '_meta'):
        meta = x._meta
        if as_copy: meta = copy(meta)
        self._meta = meta
    return self

# %% ../00_core.ipynb 41
@dispatch
def cast(x, typ):
    "cast `x` to type `typ` (may also change `x` inplace)"
    res = typ._before_cast(x) if hasattr(typ, '_before_cast') else x
    if risinstance('ndarray', res): res = res.view(typ)
    elif hasattr(res, 'as_subclass'): res = res.as_subclass(typ)
    else:
        try: res.__class__ = typ
        except: res = typ(res)
    return retain_meta(x, res)

# %% ../00_core.ipynb 47
def retain_type(new, old=None, typ=None, as_copy=False):
    "Cast `new` to type of `old` or `typ` if it's a superclass"
    # e.g. old is TensorImage, new is Tensor - if not subclass then do nothing
    if new is None: return
    assert old is not None or typ is not None
    if typ is None:
        if not isinstance(old, type(new)): return new
        typ = old if isinstance(old,type) else type(old)
    # Do nothing the new type is already an instance of requested type (i.e. same type)
    if typ==NoneType or isinstance(new, typ): return new
    return retain_meta(old, cast(new, typ), as_copy=as_copy)

# %% ../00_core.ipynb 51
def retain_types(new, old=None, typs=None):
    "Cast each item of `new` to type of matching item in `old` if it's a superclass"
    if not is_listy(new): return retain_type(new, old, typs)
    if typs is not None:
        if isinstance(typs, dict):
            t = first(typs.keys())
            typs = typs[t]
        else: t,typs = typs,None
    else: t = type(old) if old is not None and isinstance(old,type(new)) else type(new)
    return t(L(new, old, typs).map_zip(retain_types, cycled=True))

# %% ../00_core.ipynb 53
def explode_types(o):
    "Return the type of `o`, potentially in nested dictionaries for thing that are listy"
    if not is_listy(o): return type(o)
    return {type(o): [explode_types(o_) for o_ in o]}
